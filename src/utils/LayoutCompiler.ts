// src/utils/LayoutCompiler.ts
import type { ComponentSlotConfig, ComponentConfig } from '@/config/furniture'

export type PathSchema = Record<string, string | null>
export type SlotProperties = Record<string, Partial<ComponentSlotConfig>>

export class LayoutCompiler {
  private componentLookup: (id: string) => ComponentConfig | undefined

  constructor(componentLookup: (id: string) => ComponentConfig | undefined) {
    this.componentLookup = componentLookup
  }

  /**
   * Compiles a path-based schema into a flat list of ComponentSlotConfigs.
   * @param rootComponentId The ID of the root component (e.g. the corpus).
   * @param schema The path-based schema (e.g. { "root__attach_front": "door_id" }).
   * @returns A list of ComponentSlotConfig objects (children only, root is handled by Composer).
   */
  compile(
    rootComponentId: string,
    schema: PathSchema,
    schemaId?: string,
    slotProperties?: SlotProperties,
  ): ComponentSlotConfig[] {
    const slots: ComponentSlotConfig[] = []

    // 1. Define Root Context
    // A Composer gondoskodik a valódi korpuszról, mi csak a gyerekeit generáljuk.
    // Feltételezzük, hogy a korpusz ID-ja 'corpus_1' (ez a standard).
    // Ha a jövőben dinamikus a korpusz ID, azt paraméterként kellene átadni.
    const rootSlotId = 'corpus_1'
    const rootPath = 'root'

    // Ellenőrizzük, hogy létezik-e a komponens definíció
    const rootComponent = this.componentLookup(rootComponentId)
    if (!rootComponent) {
      console.error(`LayoutCompiler: Root component '${rootComponentId}' not found.`)
      return []
    }

    // 2. Recursively process children
    this.processChildren(
      rootComponentId,
      rootSlotId,
      rootPath,
      schema,
      slots,
      schemaId,
      slotProperties,
    )

    return slots
  }

  private processChildren(
    parentComponentId: string,
    parentSlotId: string,
    parentPath: string,
    schema: PathSchema,
    slots: ComponentSlotConfig[],
    schemaId?: string,
    slotProperties?: SlotProperties,
  ) {
    const parentComponent = this.componentLookup(parentComponentId)
    if (!parentComponent || !parentComponent.attachmentPoints) return

    parentComponent.attachmentPoints.forEach((point) => {
      const currentPath = `${parentPath}__${point.id}`

      // Check if path is explicitly defined in schema
      const isDefined = Object.prototype.hasOwnProperty.call(schema, currentPath)
      const childComponentId = schema[currentPath]

      if (isDefined) {
        // Resolve component definition if ID is present
        let childComponent = null
        if (childComponentId) {
          childComponent = this.componentLookup(childComponentId)
          if (!childComponent) {
            console.warn(
              `LayoutCompiler: Component '${childComponentId}' at path '${currentPath}' not found.`,
            )
            return
          }
        }

        // Generate a deterministic Slot ID
        const baseSlotId = `slot_${currentPath.replace(/__/g, '_')}`
        const newSlotId = schemaId ? `${baseSlotId}_${schemaId}` : baseSlotId

        // Load saved properties for this path (rotation, position overrides)
        const savedProps = slotProperties?.[currentPath]

        // Determine Component Type
        let resolvedType = 'unknown'
        if (childComponent) {
          resolvedType = childComponent.componentType
        } else if (point.allowedComponentTypes && point.allowedComponentTypes.length > 0) {
          resolvedType = point.allowedComponentTypes[0]!
        }

        const newSlot: ComponentSlotConfig = {
          name: point.id,
          componentType: resolvedType,
          defaultComponent: childComponentId ?? null,
          allowedComponents: childComponentId ? [childComponentId] : [],
          position: { x: 0, y: 0, z: 0 },
          rotation: { x: 0, y: 0, z: 0 },
          scale: { x: 1, y: 1, z: 1 },
          isAutoGenerated: true,
          ...savedProps, // Apply saved properties

          // Critical fields (cannot be overridden by savedProps)
          slotId: newSlotId,
          attachToSlot: parentSlotId,
          useAttachmentPoint: point.id,
        }

        slots.push(newSlot)

        // Recurse only if there is a component
        if (childComponentId) {
          this.processChildren(
            childComponentId,
            newSlotId,
            currentPath,
            schema,
            slots,
            schemaId,
            slotProperties,
          )
        }
      }
    })
  }
}
