// src/utils/LayoutCompiler.ts
import type { ComponentSlotConfig, ComponentConfig } from '@/config/furniture'

export type PathSchema = Record<string, string | null>
export type SlotProperties = Record<string, Partial<ComponentSlotConfig>>

export class LayoutCompiler {
  private componentLookup: (id: string) => ComponentConfig | undefined

  constructor(componentLookup: (id: string) => ComponentConfig | undefined) {
    this.componentLookup = componentLookup
  }

  /**
   * Compiles a path-based schema into a flat list of ComponentSlotConfigs.
   * @param rootComponentId The ID of the root component (e.g. the corpus).
   * @param schema The path-based schema (e.g. { "root__attach_front": "door_id" }).
   * @returns A list of ComponentSlotConfig objects (children only, root is handled by Composer).
   */
  compile(
    rootComponentId: string,
    schema: PathSchema,
    schemaId?: string,
    slotProperties?: SlotProperties,
    fullSchemaObj?: any,
  ): ComponentSlotConfig[] {
    const slots: ComponentSlotConfig[] = []

    // 1. Define Root Context
    // A Composer gondoskodik a valódi korpuszról, mi csak a gyerekeit generáljuk.
    // Feltételezzük, hogy a korpusz ID-ja 'corpus_1' (ez a standard).
    // Ha a jövőben dinamikus a korpusz ID, azt paraméterként kellene átadni.
    const rootSlotId = 'corpus_1'
    const rootPath = 'root'

    // Ellenőrizzük, hogy létezik-e a komponens definíció
    const rootComponent = this.componentLookup(rootComponentId)
    if (!rootComponent) {
      console.error(`LayoutCompiler: Root component '${rootComponentId}' not found.`)
      return []
    }

    // --- AUTOMATIKUS POLC GENERÁLÁS ---
    if (fullSchemaObj?.type === 'shelf' && fullSchemaObj?.shelfConfig?.mode === 'auto') {
      this.generateAutoShelves(
        rootComponent,
        rootSlotId,
        fullSchemaObj.shelfConfig,
        slots,
        schemaId,
      )
      return slots // Ha auto polc van, akkor itt végzünk is, nem kell a fa bejárás
    }

    // 2. Recursively process children
    this.processChildren(
      rootComponentId,
      rootSlotId,
      rootPath,
      schema,
      slots,
      schemaId,
      slotProperties,
    )

    return slots
  }

  // A MATEK
  private generateAutoShelves(
    corpus: ComponentConfig,
    parentSlotId: string,
    config: { count: number; componentId: string | null },
    slots: ComponentSlotConfig[],
    schemaId?: string,
  ) {
    if (!config.componentId || config.count <= 0) return

    // 1. Adatok kinyerése
    const height = corpus.properties?.height || 720 // Default 720mm
    const thickness = corpus.properties?.wallThickness || 18 // Default 18mm

    // 2. Hasznos belső magasság (Teljes - (Alja + Teteje))
    const innerHeight = height - 2 * thickness

    // 3. Osztás (Polcok száma + 1 részre osztjuk a teret)
    // Pl. 1 polc -> 2 rész (felező)
    // Pl. 2 polc -> 3 rész (harmadoló)
    const sectionHeight = innerHeight / (config.count + 1)

    // 4. Generálás
    for (let i = 1; i <= config.count; i++) {
      // Y pozíció: Alsó vastagság + (i * szakasz magasság)
      // Three.js-ben a pozíció általában a középponttól van, vagy a talptól.
      // Feltételezzük, hogy a polc pivot pontja a polc alja/közepe, és a korpusz 0-tól indul.
      // Ha a korpusz pivotja máshol van, itt kell majd finomhangolni.
      // Most feltételezzük: Y = 0 a korpusz alja.

      const posY = thickness + sectionHeight * i

      const newSlotId = `auto_shelf_${i}_${schemaId || 'temp'}`

      const newSlot: ComponentSlotConfig = {
        slotId: newSlotId,
        name: `Automata Polc ${i}`,
        componentType: 'shelves',
        defaultComponent: config.componentId,
        allowedComponents: [config.componentId],
        isAutoGenerated: true,
        attachToSlot: parentSlotId,
        useAttachmentPoint: '', // Nem használunk dummy pontot!

        // POZÍCIÓ (A lényeg)
        position: { x: 0, y: posY, z: 0 }, // mm -> méter konverzió Three.js-hez!
        rotation: { x: 0, y: 0, z: 0 },
        scale: { x: 1, y: 1, z: 1 },
      }

      slots.push(newSlot)
    }
  }

  private processChildren(
    parentComponentId: string,
    parentSlotId: string,
    parentPath: string,
    schema: PathSchema,
    slots: ComponentSlotConfig[],
    schemaId?: string,
    slotProperties?: SlotProperties,
  ) {
    const parentComponent = this.componentLookup(parentComponentId)
    if (!parentComponent || !parentComponent.attachmentPoints) return

    parentComponent.attachmentPoints.forEach((point) => {
      const currentPath = `${parentPath}__${point.id}`

      // Check if path is explicitly defined in schema
      const isDefined = Object.prototype.hasOwnProperty.call(schema, currentPath)
      const childComponentId = schema[currentPath]

      if (isDefined) {
        // Resolve component definition if ID is present
        let childComponent = null
        if (childComponentId) {
          childComponent = this.componentLookup(childComponentId)
          if (!childComponent) {
            console.warn(
              `LayoutCompiler: Component '${childComponentId}' at path '${currentPath}' not found.`,
            )
            return
          }
        }

        // Generate a deterministic Slot ID
        const baseSlotId = `slot_${currentPath.replace(/__/g, '_')}`
        const newSlotId = schemaId ? `${baseSlotId}_${schemaId}` : baseSlotId

        // Load saved properties for this path (rotation, position overrides)
        const savedProps = slotProperties?.[currentPath]

        // Determine Component Type
        let resolvedType = 'unknown'
        if (childComponent) {
          resolvedType = childComponent.componentType
        } else if (point.allowedComponentTypes && point.allowedComponentTypes.length > 0) {
          resolvedType = point.allowedComponentTypes[0]!
        }

        const newSlot: ComponentSlotConfig = {
          name: point.id,
          componentType: resolvedType,
          defaultComponent: childComponentId ?? null,
          allowedComponents: childComponentId ? [childComponentId] : [],
          position: { x: 0, y: 0, z: 0 },
          rotation: { x: 0, y: 0, z: 0 },
          scale: { x: 1, y: 1, z: 1 },
          isAutoGenerated: true,
          ...savedProps, // Apply saved properties

          // Critical fields (cannot be overridden by savedProps)
          slotId: newSlotId,
          attachToSlot: parentSlotId,
          useAttachmentPoint: point.id,
        }

        slots.push(newSlot)

        // Recurse only if there is a component
        if (childComponentId) {
          this.processChildren(
            childComponentId,
            newSlotId,
            currentPath,
            schema,
            slots,
            schemaId,
            slotProperties,
          )
        }
      }
    })
  }
}
