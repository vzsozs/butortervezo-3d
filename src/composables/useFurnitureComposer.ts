// src/composables/useFurnitureComposer.ts
import { computed, type Ref } from 'vue'
import type { FurnitureConfig, ComponentSlotConfig } from '@/config/furniture'
import { useConfigStore } from '@/stores/config'
import { LayoutCompiler } from '@/utils/LayoutCompiler'

export function useFurnitureComposer(
  furniture: Ref<FurnitureConfig | null>,
  activeSchemaId: Ref<string | null>,
) {
  const configStore = useConfigStore()

  // Ez a "Varázsló", ami összeállítja a végleges képet
  const composedSlots = computed(() => {
    if (!furniture.value) return []

    // 1. ALAPOK: Különválasztjuk a Korpuszt és a Manuális elemeket
    const rawSlots = furniture.value.componentSlots || []
    const corpusSlot = rawSlots.find((s) => s.slotId.startsWith('corpus'))

    // Ha nincs korpusz, nincs bútor
    if (!corpusSlot) return []

    // A manuális elemek (amiket az Általános fülön adtál hozzá, pl. Láb, Alap Ajtó)
    // Fontos: A generált szemetet (ha maradt volna) itt kiszűrjük
    const manualSlots = rawSlots.filter(
      (s) => !s.slotId.startsWith('corpus') && !s.isAutoGenerated && !s.slotId.startsWith('slot_'),
    )

    // Ha nincs aktív séma, akkor egyszerűen visszaadjuk az eredetit (tisztítva)
    if (!activeSchemaId.value) {
      return [corpusSlot, ...manualSlots]
    }

    // 2. SÉMA GENERÁLÁS
    const layoutGroup = furniture.value.slotGroups?.find((g) => g.name === 'Layouts')
    const schema = layoutGroup?.schemas.find((s) => s.id === activeSchemaId.value)

    if (!schema) {
      // Ha van ID, de nincs séma (hiba), vissza az alaphoz
      return [corpusSlot, ...manualSlots]
    }

    // Generáljuk le a séma elemeit
    const compiler = new LayoutCompiler((id) => configStore.getComponentById(id))
    // Fontos: A korpusz komponens ID-ja kell a compilernek
    const rootComponentId = corpusSlot.defaultComponent

    let generatedSlots: ComponentSlotConfig[] = []
    if (rootComponentId) {
      generatedSlots = compiler.compile(
        rootComponentId,
        schema.apply,
        activeSchemaId.value,
        schema.slotProperties,
      )
    }

    // 3. ÖSSZEFÉSÜLÉS (A "Composer" logika)
    // Megnézzük, mit kell elrejteni a manuális elemek közül
    const schemaType = schema.type
    const typesToHide: string[] = []

    if (schemaType === 'front') {
      typesToHide.push('fronts', 'handles', 'hinges', 'front', 'handle')
    } else if (schemaType === 'drawer') {
      typesToHide.push('drawers', 'handles', 'drawer_fronts', 'drawer', 'handle')
    } else if (schemaType === 'shelf') {
      typesToHide.push('shelves', 'shelf')
    } else if (schemaType === 'leg') {
      typesToHide.push('legs', 'leg')
    }

    // Szűrjük a manuális elemeket
    const visibleManualSlots = manualSlots.filter((slot) => {
      // Ha a típusa benne van a tiltólistában, kuka
      if (typesToHide.includes(slot.componentType)) return false

      // Extra biztonság: Név alapú szűrés (ha a típus nem lenne pontos)
      if (
        schemaType === 'front' &&
        (slot.slotId.startsWith('front') || slot.slotId.startsWith('handle'))
      )
        return false
      if (schemaType === 'leg' && slot.slotId.startsWith('leg')) return false

      return true
    })

    // 4. VÉGEREDMÉNY
    // Korpusz + Generáltak (Séma) + Megmaradt Manuálisok
    return [corpusSlot, ...generatedSlots, ...visibleManualSlots]
  })

  return {
    composedSlots,
  }
}
