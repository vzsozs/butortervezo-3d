// src/composables/useFurnitureComposer.ts
import { computed, type Ref } from 'vue'
import type { FurnitureConfig, ComponentSlotConfig } from '@/config/furniture'
import { useConfigStore } from '@/stores/config'
import { LayoutCompiler } from '@/utils/LayoutCompiler'

const CONFLICT_MAP: Record<string, string[]> = {
  front: ['front', 'door', 'handle', 'knob', 'hinge', 'opening', 'ajt√≥', 'foganty√∫'],
  drawer: ['drawer', 'runner', 'pull', 'front', 'fi√≥k'],
  shelf: ['shelf', 'shelves', 'divider', 'polc'],
  leg: ['leg', 'foot', 'plinth', 'base', 'l√°b'],
  internal: ['shelf', 'drawer', 'divider', 'inner'],
}

export function useFurnitureComposer(
  furniture: Ref<FurnitureConfig | null>,
  activeSchemaId: Ref<string | null>,
) {
  const configStore = useConfigStore()

  const composedSlots = computed(() => {
    // DEBUG START
    console.groupCollapsed('üé® Composer Calculation Triggered')

    if (!furniture.value) {
      console.log('‚ùå No furniture data')
      console.groupEnd()
      return []
    }

    // 1. ALAPOK
    const rawSlots = furniture.value.componentSlots || []
    const corpusSlot = rawSlots.find((s) => s.slotId.toLowerCase().includes('corpus'))

    if (!corpusSlot) {
      console.warn('‚ö†Ô∏è No corpus slot found!')
      console.groupEnd()
      return []
    }

    const manualSlots = rawSlots.filter(
      (s) =>
        !s.slotId.toLowerCase().includes('corpus') &&
        !s.isAutoGenerated &&
        !s.slotId.startsWith('slot_'),
    )

    console.log(`üì¶ Base State: 1 Corpus + ${manualSlots.length} Manual Slots`)

    if (!activeSchemaId.value) {
      console.log('‚ÑπÔ∏è No active schema. Returning base state.')
      console.groupEnd()
      return [corpusSlot, ...manualSlots]
    }

    // 2. S√âMA GENER√ÅL√ÅS
    console.log(`üîß Active Schema ID: ${activeSchemaId.value}`)
    const layoutGroup = furniture.value.slotGroups?.find((g) => g.name === 'Layouts')
    const schema = layoutGroup?.schemas.find((s) => s.id === activeSchemaId.value)

    if (!schema) {
      console.warn('‚ö†Ô∏è Schema ID not found in furniture config!')
      console.groupEnd()
      return [corpusSlot, ...manualSlots]
    }

    const compiler = new LayoutCompiler((id) => configStore.getComponentById(id))
    const rootComponentId = corpusSlot.defaultComponent

    let generatedSlots: ComponentSlotConfig[] = []
    if (rootComponentId) {
      generatedSlots = compiler.compile(
        rootComponentId,
        schema.apply,
        activeSchemaId.value,
        schema.slotProperties,
      )
    }
    console.log(`‚ú® Generated ${generatedSlots.length} slots from schema`)

    // 3. SZ≈∞R√âS (DEBUG LOGGAL)
    const schemaType = schema.type || 'default'
    const keywordsToHide = CONFLICT_MAP[schemaType] || []

    console.log(`üö´ Filtering Rules for type '${schemaType}':`, keywordsToHide)

    const visibleManualSlots = manualSlots.filter((slot) => {
      const type = (slot.componentType || '').toLowerCase()
      const id = (slot.slotId || '').toLowerCase()

      const isConflicting = keywordsToHide.some(
        (keyword) => type.includes(keyword) || id.includes(keyword),
      )

      // R√©szletes log a d√∂nt√©sr≈ël
      if (isConflicting) {
        console.log(
          `   ‚ùå Hiding manual slot: ${slot.slotId} (Type: ${slot.componentType}) - Match found`,
        )
        return false
      } else {
        console.log(`   ‚úÖ Keeping manual slot: ${slot.slotId} (Type: ${slot.componentType})`)
        return true
      }
    })

    const finalResult = [corpusSlot, ...generatedSlots, ...visibleManualSlots]
    console.log(`üèÅ Final Result: ${finalResult.length} slots total`)
    console.groupEnd()

    return finalResult
  })

  return { composedSlots }
}
